{
  "_args": [
    [
      {
        "raw": "sc-broker@~3.0.0",
        "scope": null,
        "escapedName": "sc-broker",
        "name": "sc-broker",
        "rawSpec": "~3.0.0",
        "spec": ">=3.0.0 <3.1.0",
        "type": "range"
      },
      "C:\\Users\\Pulego-PC\\Documents\\FlatApp\\node_modules\\sc-broker-cluster"
    ]
  ],
  "_from": "sc-broker@>=3.0.0 <3.1.0",
  "_id": "sc-broker@3.0.0",
  "_inCache": true,
  "_location": "/sc-broker",
  "_nodeVersion": "7.10.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/sc-broker-3.0.0.tgz_1499206748312_0.2897623295430094"
  },
  "_npmUser": {
    "name": "topcloudsystems",
    "email": "grosjona@yahoo.com.au"
  },
  "_npmVersion": "4.2.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "sc-broker@~3.0.0",
    "scope": null,
    "escapedName": "sc-broker",
    "name": "sc-broker",
    "rawSpec": "~3.0.0",
    "spec": ">=3.0.0 <3.1.0",
    "type": "range"
  },
  "_requiredBy": [
    "/sc-broker-cluster"
  ],
  "_resolved": "https://registry.npmjs.org/sc-broker/-/sc-broker-3.0.0.tgz",
  "_shasum": "a34491816bdc2aaf6f23562c942eb9505eb5477d",
  "_shrinkwrap": null,
  "_spec": "sc-broker@~3.0.0",
  "_where": "C:\\Users\\Pulego-PC\\Documents\\FlatApp\\node_modules\\sc-broker-cluster",
  "author": {
    "name": "JF Gros-Dubois",
    "email": "flashthink@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/SocketCluster/sc-broker/issues"
  },
  "contributors": [
    {
      "name": "JF Gros-Dubois",
      "email": "flashthink@gmail.com"
    },
    {
      "name": "wactbprot"
    }
  ],
  "dependencies": {
    "expirymanager": "~0.9.3",
    "fleximap": "~0.9.10",
    "ncom": "~0.11.1",
    "sc-domain": "~1.0.1",
    "sc-errors": "~1.3.0"
  },
  "description": "sc-broker key-value and message broker",
  "devDependencies": {
    "istanbul": "0.4.4",
    "mocha": "3.0.2",
    "underscore": "1.8.3"
  },
  "directories": {},
  "dist": {
    "shasum": "a34491816bdc2aaf6f23562c942eb9505eb5477d",
    "tarball": "https://registry.npmjs.org/sc-broker/-/sc-broker-3.0.0.tgz"
  },
  "engines": {
    "node": ">= 0.8.0"
  },
  "gitHead": "669e1e0500aba87f57af5de8e4d7cc7db448cc0b",
  "homepage": "https://github.com/SocketCluster/sc-broker#readme",
  "keywords": [
    "store",
    "broker",
    "message broker",
    "key value server",
    "session",
    "socketcluster"
  ],
  "main": "index",
  "maintainers": [
    {
      "name": "topcloudsystems",
      "email": "grosjona@yahoo.com.au"
    }
  ],
  "name": "sc-broker",
  "optionalDependencies": {},
  "readme": "sc-broker\r\n======\r\n\r\n*scBroker* is a lightweight key-value store and message broker.\r\nIt is written entirely in node.js for maximum portability.\r\n\r\n## Installation\r\n\r\n```bash\r\nnpm install sc-broker\r\n```\r\n\r\n## Overview\r\n\r\nTo use it call:\r\n\r\n```js\r\nvar scBroker = require('sc-broker');\r\n```\r\n\r\nFirstly, launch a new *scBroker* server. If you're using the node cluster module,\r\nyou might want to launch the *scBroker* server once from the master process and\r\nthen interact with it using *scBroker* clients.\r\n\r\n## Server\r\n\r\nTo launch the **server**, use:\r\n\r\n```js\r\nvar dataServer = scBroker.createServer({port: 9000, secretKey: 'mySecretKey'})\r\n```\r\n\r\nThe ```secretKey``` argument is optional; you should use it if you want to\r\nrestrict access to the server. If you're running a node cluster, you may want\r\nto use a random key and distribute it to all the workers so that only your\r\napplication can interact with the *scBroker* server.\r\n\r\nOnce the server is setup, you should create clients to interact with it.\r\n\r\n**Make sure that the server is running before creating clients**\r\n\r\nThis ca be done in the following way:\r\n\r\n```js\r\nvar conf = {port: 9000}\r\n  , server = scBroker.createServer(conf);\r\n\r\nserver.on('ready', function () {\r\n\r\n console.log('Server ready, create client');\r\n var client = scBroker.createClient(conf);\r\n\r\n // do client stuff\r\n\r\n});\r\n```\r\nAfter all the server provides a destroy function:\r\n\r\n```js\r\nserver.destroy()\r\n```\r\n\r\n## Client\r\n\r\nTo create a **client** use:\r\n\r\n```js\r\nvar dataClient = scBroker.createClient({port: 9000, secretKey: 'mySecretKey'});\r\n```\r\n\r\nThe ```port``` and ```secretKey``` must match those supplied to the\r\ncreateServer function.\r\n\r\n### Client methods\r\n\r\nThe client exposes the following methods:\r\n(Please see the [section on keys ](https://github.com/SocketCluster/sc-broker#keys) to\r\nsee how you can use keys in *scBroker*. Also, note that the callback argument in\r\nall of the following cases is optional.)\r\n\r\n\r\n#### run\r\n\r\n```js\r\nrun(code,[data,] callback)\r\n```\r\nRun a special JavaScript function\r\ndeclaration (code) as a query *on the scBroker server*. This function declaration\r\naccepts the DataMap as a parameter.\r\nThis is the most important function in *scBroker*, all the other functions are\r\nbasically utility functions to make things quicker. Using run() offers the\r\nmost flexibility. The *callback* is in form:\r\n```\r\ncallback(err, data)\r\n```\r\n\r\n**Example:**\r\n\r\n```js\r\nvar queryFn = function (DataMap) {\r\n    // The myMessage variable comes from queryFn.data\r\n    DataMap.set(['main', 'message'], myMessage);\r\n    return DataMap.get(['main']);\r\n};\r\n\r\nqueryFn.data = {\r\n    myMessage: 'This is an important message'\r\n};\r\n\r\nclient.run(queryFn, function (err, data) {\r\n    console.log(data); // outputs {message: \"This is an important message\"}\r\n});\r\n```\r\n**Note**\r\n\r\nThe *query functions* are **not** regular functions. Query functions are\r\nexecuted remotely (on the *scBroker* server), therefore, you cannot access\r\nvariables from the outer parent scope while inside them.\r\n\r\nTo pass data from the current process to use inside your query functions, you\r\nneed to set them through the data  property (see ```queryFn.data```) in\r\nexample above. Properties of ```queryFn.data``` will be available as regular\r\nvariables inside the query function when it gets executed on the server.\r\nAll query data is escaped automatically, so it's safe to supply user\r\ninput. The ```queryFn.data``` property is optional.\r\n\r\n\r\n#### set\r\n\r\n```js\r\nset(keyChain, value, callback)\r\n```\r\nSet a key-value pair, when the operation has been completed, callback will be\r\nexecuted. The callback is in form:\r\n```js\r\ncallback(err)\r\n```\r\n\r\n#### add\r\n\r\n```js\r\nadd(keyChain, value, callback)\r\n```\r\nAppend a value at the given ```keyChain```; the object at ```keyChain``` will\r\nbe *treated as an array*. If a value already exists at that ```keyChain``` and\r\nis not an array, this existing value will be placed inside an empty array and\r\nthe specified value argument will be appended to that array. The callback is\r\nin form:\r\n```js\r\ncallback(err, insertionIndex)\r\n```\r\n\r\n#### concat\r\n\r\n```js\r\nconcat(keyChain, value, callback)\r\n```\r\nConcatenate the array or object at ```keyChain``` with the specified array or\r\nobject (```value```). The callback is in form:\r\n```js\r\ncallback(err)\r\n```\r\n\r\n#### remove\r\n\r\n```js\r\nremove(keyChain,[getValue,] callback)\r\n```\r\nRemove the value at ```keyChain```. If value is an array, it will remove the\r\nentire array. The optional ```getValue``` is a *boolean* which indicates\r\nwhether or not to *return* the removed value *in the callback*. The callback\r\nis in form:\r\n```js\r\ncallback(err, value)\r\n```\r\n\r\n#### removeRange\r\n\r\n```js\r\nremoveRange(keyChain, fromIndex,[ toIndex, getValue,] callback)\r\n```\r\nRemove a range of values at ```keyChain``` between ```fromIndex``` and\r\n```toIndex```. This function assumes that the value at ```keyChain``` is an\r\nobject or array. The optional ```getValue``` argument specifies whether or not\r\nto *return* the removed section as an *argument to the callback*. The callback\r\nis in form:\r\n```js\r\ncallback(err, value)\r\n```\r\n\r\n#### removeAll\r\n\r\n```js\r\nremoveAll(callback)\r\n```\r\nClear *scBroker* *completely*. The callback is in form:\r\n```js\r\ncallback(err)\r\n```\r\n\r\n#### splice\r\n\r\n```js\r\nsplice(keyChain,[ options,] callback)\r\n```\r\n\r\nThis operation is designed to work on Arrays (the keyChain argument should point to an Array).\r\nIt is similar to JavaScript's Array.splice() function. It can be used to remove and insert elements\r\nwithin an Array.\r\nThe options argument is an object which can have the following properties:\r\n- index // The index at which to start inserting/deleting\r\n- count // The number of items to delete starting from index\r\n- items // An Array of items to insert at index\r\n\r\nCallback form:\r\n\r\n```js\r\ncallback(err, value)\r\n```\r\n\r\n#### pop\r\n\r\n```js\r\npop(keyChain,[getValue,] callback)\r\n```\r\n\r\nRemove the *last numerically-indexed entry* at ```keyChain```. The optional\r\n``getValue`` is a *boolean* which indicates whether or not to *return* the\r\nremoved value in the callback. The callback is in form:\r\n```js\r\ncallback(err, value)\r\n```\r\n\r\n#### get\r\n\r\n```js\r\nget(keyChain, callback)\r\n```\r\nGet the value at ```keyChain```. The callback is in form:\r\n```js\r\ncallback(err, value)\r\n```\r\n#### getRange\r\n\r\n```js\r\ngetRange(keyChain, fromIndex,[ toIndex,] callback)\r\n```\r\nThis function assumes that the value at ```keyChain``` is an Array or Object.\r\nCapture all values starting at ```fromIndex``` and finishing at ```toIndex```\r\nbut **not including** ```toIndex```. If ```toIndex``` is not specified, all\r\nvalues from ```fromIndex``` until the end of the Array or Object will be\r\nincluded. The callback is in form:\r\n```js\r\ncallback(err, value)\r\n```\r\n\r\n#### getAll\r\n\r\n```js\r\ngetAll(callback)\r\n```\r\nGet all the values in *scBroker*. The callback is in form:\r\n```js\r\ncallback(err, value)\r\n```\r\n\r\n#### count\r\n\r\n```js\r\ncount(keyChain, callback)\r\n```\r\nCount the number of elements at ```keyChain```. The callback is in form:\r\n```js\r\ncallback(err, value)\r\n```\r\n## publish subscribe\r\n\r\n*scBroker* provides [publish and subscribe](http://redis.io/topics/pubsub)\r\n functionality.\r\n\r\n\r\n#### subscribe\r\n\r\n```js\r\nsubscribe(channel, ackCallback)\r\n```\r\nWatch a ```channel``` on *scBroker*. This is the *scBroker* equivalent to\r\n[Redis' ```subscribe()```](http://redis.io/commands/subscribe). When an event\r\nhappens on any watched channel, you can handle it using\r\n```js\r\nscBrokerClient.on('message', function (channel, data) {\r\n    // ...\r\n})\r\n```\r\n\r\n#### unsubscribe\r\n\r\n```js\r\nunsubscribe(channel, ackCallback)\r\n```\r\nUnwatch the specified ```channel```. If ```channel``` is not specified, it\r\nwill unsubscribe from all channels.\r\n\r\n#### on\r\n\r\n```js\r\non(event, listener)\r\n```\r\nListen to events on *scBroker*, you should listen to the 'message' event to handle\r\nmessages from subscribed channels. Events are:\r\n\r\n* ```'ready'```: Triggers when *scBroker* is initialized and connected. You often\r\n    don't need to wait for that event though. The *scBroker* client will buffer\r\n    actions until the *scBroker* server ready.\r\n* ```'exit'``` This event carries two arguments to it's listener: ```code```\r\n    and ```signal```. It gets triggered when the *scBroker* **server** process\r\n    dies.\r\n* ```'connect_failed'``` This happens if the *scBroker* **client** fails to\r\n    connect to the server after the maximum number of retries have been\r\n    attempted.\r\n* ```'message'``` Captures data published to a channel which the client is\r\n    subscribed to.\r\n* ```'subscribe'``` Triggers whenever a successful subscribe operations occurs.\r\n* ```'subscribefail'``` Triggers whenever a subscribtion fails.\r\n* ```'unsubscribe'``` Triggers on a successful unsubscribe operation.\r\n* ```'unsubscribefail'``` Triggers whenever a unsubscribtion fails.\r\n* ```'error'``` Triggers whenever a error occurs.\r\n\r\n#### publish\r\n\r\n```js\r\npublish(channel, message, callback)\r\n```\r\nPublish data to a channel - Can be any JSON-compatible JavaScript object.\r\n\r\n**Example:**\r\n\r\nAfter starting the server (*server.js*):\r\n\r\n```js\r\nvar scBroker = require('sc-broker')\r\n  , dss   = scBroker.createServer({port: 9000})\r\n```\r\n\r\na first client (*client1.js*) can subscribe to channel ```foo``` and listen\r\nto ```messages```:\r\n\r\n```js\r\nvar scBroker = require('sc-broker')\r\n  , dc       = scBroker.createClient({port: 9000})\r\n  , ch       = 'foo'\r\n  , onMsgFn  = function (ch, data) {\r\n      console.log('message on channel ' + ch );\r\n      console.log('data:');\r\n      console.log(data);\r\n    }\r\ndc.subscribe(ch, function (err) {\r\n  if (!err) {\r\n    console.log('client 1 subscribed channel ' + ch  );\r\n  }\r\n})\r\ndc.on('message', onMsgFn )\r\n```\r\n\r\nIf a second client (*client2.js*) publishes a message, the first client will\r\nexecute the ```onMsgFn``` function:\r\n\r\n```js\r\nvar scBroker  = require('sc-broker')\r\n   , dc    = scBroker.createClient({port: 9000})\r\n   , data  = {a: 'b'}\r\n   , ch    = 'foo';\r\ndc.publish(ch,data , function (err) {\r\n  if (!err) {\r\n    console.log('client 2 published data:');\r\n    console.log(data);\r\n  }\r\n})\r\n```\r\n\r\n## Keys\r\n\r\n*scBroker* is very flexible with how you can use keys. It lets you set key chains\r\nof any dimension without having to manually create each link in the chain.\r\n\r\nA key chain is an array of keys - Each subsequent key in the chain is a child\r\nof the previous key.\r\nFor example, consider the following object:\r\n```js\r\n{'this': {'is': {'a': {'key': 123}}}}\r\n```\r\nThe key chain ```['this', 'is', 'a', 'key']``` would reference the number\r\n```123```. The key chain ```['this', 'is']``` would reference the object\r\n```{'a': {'key': 123}}```, etc.\r\n\r\nWhen you start, *scBroker* will be empty, but this code is perfectly valid:\r\n```js\r\ndataClient.set(['this', 'is', 'a', 'deep', 'key'], 'Hello world');\r\n```\r\nIn this case, *scBroker* will *create* the necessary key chain and set the\r\nbottom-level 'key' to 'Hello World'.\r\nIf you were to call:\r\n```js\r\ndataClient.get(['this', 'is', 'a'], function (err, val) {\r\n    console.log(val);\r\n});\r\n```\r\nThe above would output:\r\n```js\r\n{deep:{key:'Hello world'}}\r\n```\r\n\r\n*scBroker* generally doesn't restrict you from doing anything you want. Following\r\nfrom the previous example, it is perfectly OK to call this:\r\n```js\r\ndataClient.add(['this', 'is', 'a'], 'foo');\r\n```\r\nIn this case, the key chain ```['this', 'is', 'a']``` would evaluate to:\r\n```js\r\n{0:'foo', deep:{key:'Hello world'}}\r\n```\r\nIn this case, *scBroker* will add the value at the next numeric index in the\r\nspecified key path (which in this case is 0).\r\n\r\nYou can access numerically-indexed values like this:\r\n```js\r\ndataClient.get(['this', 'is', 'a', 0], function (err, val) {\r\n    console.log(val);\r\n});\r\n```\r\nThe output here will be 'foo'.\r\nYou can also add entire JSON-compatible objects as value.\r\n\r\n\r\n## Tests\r\n\r\nTo run tests, go to the sc-broker module directory then run:\r\n\r\n```bash\r\nnpm test\r\n```\r\n\r\nIf you get an error, make sure that you have mocha installed:\r\n\r\n```bash\r\nnpm install mocha\r\n```\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/SocketCluster/sc-broker.git"
  },
  "scripts": {
    "cover": "istanbul cover _mocha -- --reporter spec --timeout 3000 --slow 3000",
    "start": "node server.js",
    "test": "mocha --reporter spec --timeout 3000 --slow 3000"
  },
  "version": "3.0.0"
}
